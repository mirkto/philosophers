
<strings.h>	strerror - 00
<stdlib.h>	malloc, free, exit
			\___00, \_00, \_84
<unistd.h>	write, read, close, fork, getcwd, chdir, execve, dup, dup2, pipe
			\__52, \_52, \__54, \_77, \___00, \__75, \___80, \______96, \120
<fcntl.h>	open - 50
<signal.h>	signal, kill - 109
<dirent.h>	opendir, readdir, closedir - 66
<errno.h>	errno - 00
<sys/wait.h>	wait, waitpid - 87
<sys/types.h>	wait3, wait4 - 88
<sys/stat.h>	stat, lstat, fstat - 61

memset - заполняет первые len байт по указателю dest символом c
printf - умный вывод на экран
malloc - выделение памяти
free - освобождение памяти
write - вывод на экран
usleep - приостанавливает работу потока, на время в микросекундах
gettimeofday - заполняет структуру временем от начала эпохи
pthread_create - создание потока
pthread_join - ожидание завершения процесса
pthread_detach - отсоединяет процесс (при завершении, все занимаемые им
			ресурсы освобождаются и мы не можем отслеживать его завершение)
pthread_mutex_init - создание мьютекса
pthread_mutex_destroy - закрытие мьютекса
pthread_mutex_lock - закрыть мьютекс
pthread_mutex_unlock - открыть мьютекс

колличество философов и вилок - number_of_philosophers;
время смерти, если столько без еды - time_to_die;
время на еду - time_to_eat;
время на сон - time_to_sleep;
сколько надо поесть всем - number_of_times_each_philosopher_must_eat;

ft_putendl("---");

ft_putnbr(len);
ft_putendl("");

write(1, "\n", 1);

alias mm="make && ./minishell"

//-----пример_работы_gettimeofday--------
#include <sys/time.h>

struct timeval tv1, tv2, dtv;
struct timezone tz;

void	time_start()
{
	gettimeofday(&tv1, &tz);
}

long	time_stop()
{
	gettimeofday(&tv2, &tz);
	dtv.tv_sec = tv2.tv_sec - tv1.tv_sec;
	dtv.tv_usec = tv2.tv_usec - tv1.tv_usec;
	if(dtv.tv_usec < 0)
	{
		dtv.tv_sec--;
		dtv.tv_usec += 1000000;
	}
	return (dtv.tv_sec * 1000 + dtv.tv_usec / 1000);
}

main()

{
	...
	time_start();
		/* какие-то действия */
	printf("Time: %ld\n", time_stop());
	...
}